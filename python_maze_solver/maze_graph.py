#!/usr/bin/env python3
"""
Generate an adjacency graph from a maze JSON using wall bits N=1,E=2,S=4,W=8.

Usage examples:
  python maze_graph.py labyrinth.json --print-adj
  python maze_graph.py labyrinth.json --dot maze.dot
  python maze_graph.py labyrinth.json --cpp maze_graph.h
"""

import argparse
import json
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

N, E, S, W = 1, 2, 4, 8
OPPOSITE = {N: S, E: W, S: N, W: E}
DIRS = [(0, -1, N), (1, 0, E), (0, 1, S), (-1, 0, W)]

Coord = Tuple[int, int]
Graph = Dict[Coord, List[Coord]]


def parse_coord(val, name: str) -> Optional[Coord]:
    if val is None:
        return None
    if isinstance(val, (list, tuple)) and len(val) == 2:
        return int(val[0]), int(val[1])
    raise ValueError(f"{name} must be [x, y] if provided")


def load_maze(path: Path):
    data = json.loads(path.read_text(encoding="utf-8"))
    if isinstance(data, dict) and "grid" in data:
        grid_raw = data["grid"]
        start = parse_coord(data.get("start"), "start")
        end = parse_coord(data.get("end"), "end")
        points_raw = data.get("points") or []
    else:
        grid_raw = data
        start = end = None
        points_raw = []
    if not isinstance(grid_raw, list) or not all(isinstance(r, list) for r in grid_raw):
        raise ValueError("grid must be a 2D array")
    grid: List[List[int]] = [[int(cell) for cell in row] for row in grid_raw]
    if not grid:
        raise ValueError("grid is empty")
    widths = {len(r) for r in grid}
    if len(widths) != 1:
        raise ValueError("all grid rows must have the same length")
    points: List[Coord] = []
    for i, p in enumerate(points_raw):
        coord = parse_coord(p, f"points[{i}]")
        if coord is not None:
            points.append(coord)
    return grid, start, end, points


def build_graph(grid: List[List[int]]) -> Graph:
    h = len(grid)
    w = len(grid[0])
    graph: Graph = {}
    for y, row in enumerate(grid):
        for x, cell in enumerate(row):
            node = (x, y)
            graph[node] = []
            for dx, dy, bit in DIRS:
                nx, ny = x + dx, y + dy
                if not (0 <= nx < w and 0 <= ny < h):
                    continue
                if cell & bit:
                    continue
                if grid[ny][nx] & OPPOSITE[bit]:
                    continue
                graph[node].append((nx, ny))
    return graph


def find_intersections(graph: Graph, min_degree: int = 3) -> List[Coord]:
    """Return nodes with degree >= min_degree."""
    return [node for node, nbs in graph.items() if len(nbs) >= min_degree]


def graph_to_cpp(
    graph: Graph,
    intersections: Set[Coord],
    width: int,
    height: int,
    start: Optional[Coord],
    end: Optional[Coord],
    points: List[Coord],
    source_name: str,
) -> str:
    """Emit a C++-friendly adjacency table with comments on intersections."""
    lines: List[str] = []
    lines.append(f"// Auto-generated by maze_graph.py from {source_name}")
    lines.append("#pragma once")
    lines.append("#include <stdint.h>")
    lines.append("")
    lines.append("struct Neighbor { uint8_t x; uint8_t y; };")
    lines.append(
        "struct Node { uint8_t x; uint8_t y; uint8_t degree; Neighbor neighbors[4]; };"
    )
    lines.append(f"static const uint8_t MAZE_WIDTH = {width};")
    lines.append(f"static const uint8_t MAZE_HEIGHT = {height};")
    lines.append(f"static const uint8_t NODE_COUNT = {len(graph)};")
    if start is not None:
        lines.append(f"static const int8_t START[2] = {{{start[0]}, {start[1]}}};")
    if end is not None:
        lines.append(f"static const int8_t END[2] = {{{end[0]}, {end[1]}}};")
    if points:
        lines.append(f"static const uint8_t POINT_COUNT = {len(points)};")
        pts = ", ".join(f"{{{p[0]}, {p[1]}}}" for p in points)
        lines.append("static const int8_t POINTS[POINT_COUNT][2] = { " + pts + " };")
    lines.append("")
    lines.append("static const Node MAZE_GRAPH[NODE_COUNT] = {")
    for node in sorted(graph):
        nbs = sorted(graph[node])
        pad = 4 - len(nbs)
        neighbors = nbs + [(255, 255)] * pad
        neighbors_str = ", ".join(f"{{{nb[0]}, {nb[1]}}}" for nb in neighbors)
        comment = f" // intersection deg={len(nbs)}" if node in intersections else ""
        lines.append(
            f"    {{{node[0]}, {node[1]}, {len(nbs)}, {{ {neighbors_str} }} }},{comment}"
        )
    lines.append("};")
    lines.append("")
    lines.append(
        "// Neighbor entries with {255, 255} are unused (padding to fixed 4 slots)."
    )
    return "\n".join(lines)


def graph_to_dot(
    graph: Graph,
    start: Optional[Coord],
    end: Optional[Coord],
    points: List[Coord],
    intersections: List[Coord],
) -> str:
    lines = [
        "graph maze {",
        "  node [shape=circle, width=0.3, height=0.3, fixedsize=true, fontsize=10];",
    ]
    special: Dict[Coord, str] = {}
    if start is not None:
        special[start] = 'style=filled, fillcolor="#b2f2bb"'
    if end is not None:
        special[end] = 'style=filled, fillcolor="#ffa8a8"'
    for idx, p in enumerate(points, start=1):
        special[p] = f'style=filled, fillcolor="#d0e4ff", xlabel="p{idx}"'
    for node in intersections:
        # avoid overwriting start/end styling
        if node not in special:
            special[node] = 'style=filled, fillcolor="#ffd8a8"'
    seen_nodes = set()
    for node in graph:
        label = f"{node[0]},{node[1]}"
        attr = special.get(node)
        if node not in seen_nodes or attr:
            lines.append(f'  "{label}"' + (f" [{attr}];" if attr else ";"))
            seen_nodes.add(node)
    edges = set()
    for node, nbs in graph.items():
        a = f"{node[0]},{node[1]}"
        for nb in nbs:
            edge = tuple(sorted([node, nb]))
            if edge in edges:
                continue
            edges.add(edge)
            b = f"{nb[0]},{nb[1]}"
            lines.append(f'  "{a}" -- "{b}";')
    lines.append("}")
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Generate adjacency graph from a maze JSON with wall bits N=1,E=2,S=4,W=8."
    )
    parser.add_argument(
        "maze", nargs="?", default="labyrinth.json", help="Path to the maze JSON file"
    )
    parser.add_argument("--dot", help="Write Graphviz DOT output to this path")
    parser.add_argument("--cpp", help="Write C++ adjacency data to this path")
    parser.add_argument(
        "--print-adj", action="store_true", help="Print adjacency list to stdout"
    )
    args = parser.parse_args()

    grid, start, end, points = load_maze(Path(args.maze))
    graph = build_graph(grid)
    intersections = find_intersections(graph)
    intersections_set: Set[Coord] = set(intersections)
    nodes = len(graph)
    edges = sum(len(nbs) for nbs in graph.values()) // 2
    print(
        f"Grid {len(grid[0])}x{len(grid)} -> graph with {nodes} nodes and {edges} edges"
    )
    if start is not None:
        print(f"Start: {start}")
    if end is not None:
        print(f"End: {end}")
    if points:
        print(f"Points: {points}")
    if intersections:
        printable = " ".join(f"{c[0]},{c[1]}" for c in sorted(intersections))
        print(f"Intersections (degree>=3): {printable}")
    else:
        print("Intersections (degree>=3): none")

    if args.print_adj or not args.dot:
        print("Adjacency list:")
        for node in sorted(graph):
            neighbours = " ".join(f"{nb[0]},{nb[1]}" for nb in sorted(graph[node]))
            print(f"{node[0]},{node[1]}: {neighbours}")

    if args.dot:
        dot = graph_to_dot(graph, start, end, points, intersections)
        Path(args.dot).write_text(dot, encoding="utf-8")
        print(f"Wrote DOT to {args.dot}")
    if args.cpp:
        cpp_text = graph_to_cpp(
            graph,
            intersections_set,
            len(grid[0]),
            len(grid),
            start,
            end,
            points,
            Path(args.maze).name,
        )
        Path(args.cpp).write_text(cpp_text, encoding="utf-8")
        print(f"Wrote C++ data to {args.cpp}")


if __name__ == "__main__":
    main()
